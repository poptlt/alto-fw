---
layout: default
title: YDB
parent: Сервер
nav_order: 2
---

Под концепцию фреймворка использовать Яндекс облако и его serverless сервисы, в плане баз данных на данный момент 
подходит только [YDB](https://cloud.yandex.ru/services/ydb). И этот модуль как раз попытка представить простой
и удобный в использовании драйвер этой БД.

Не стоит воспринимать его слишком серьезно, это скорее демонстрация-модель с очень ограниченной функциональностью. Просто сделана небольшая надстройка над [SDK](https://github.com/ydb-platform/ydb-nodejs-sdk) от Яндекса. 
Яндекс обещает через некоторое время представить свой вариант драйвера, сделанный в стиле драйвера для PostgreSQL. 
Надеемся, что он обеспечит необходимую функциональность и, вместе с тем, простоту и удобство использования.

Установка:

> **npm install 'https://gitpkg.now.sh/poptlt/alto-fw/server/ydb?master'**

Подключение:

> **const ydb = require('@alto-fw/ydb')**

При инициализации драйвера необходимо передать ему базу данных и параметры сервисного аккаунта, у которого есть необходимые права на эту базу данных.

Сервисному аккаунту нужно дать доступ к БД с ролями **ydb.viewer** и **ydb.editor**

В случае доступа к БД из вне (с локальной машины и т.п.):

> const connect = new ydb(dbName, {serviceAccount: {serviceAccountId, keyId, key}})

, где **dbName** - имя БД в формате /ru-central1/.........
, **serviceAccountId** - идентификатор сервисного аккаунта
, **keyId** - идентификатор авторизованного ключа, созданного для данного сервисного аккаунта
, **key** - собственно сам ключ

А в случае [Yandex Cloud Function](https://cloud.yandex.ru/services/functions) уже имеем на входе в контексте свежий IAM-токен и параметры сервисного аккаунта не нужны (необходимо только "привязать" сервисный аккаунт к функции, чтобы она имела соответствущие права): 

> **const connect = new ydb(dbName, {iamToken: context.token.access_token})**

Через полученный коннект можно выполнять одиночные запросы:

> **let result = await connect.query('SELECT * FROM table1 WHERE column1 = $param1', {param1: 123})**

Первым параметром асинхронной функции **query** идет собственно запрос, вторым - объект с параметрами. 
Результатом будет массив объектов с ключами-именами полей.

У YDB строгая типизация параметров. Драйвер преобразует типы JS в типы YDB:

| JS | YDB |
|----|-----|
| boolean | Bool |
| number в случае целого положительного (или ноль) числа | Uint64 |
| number в случае целого отрицательного числа | Int64 |
| number в остальных случаях | Double |
| bigint положительный (или ноль) | Uint64 |
| bigint отрицательный | Int64 |
| string | Utf8 |
| object в случае instanceof Date | Timestamp |
| object в остальных случаях (естественно объект должен быть сериализуемым) | Json |

Другие типы JS вызывают ошибку. Если в запросе необходим параметр другого типа, то в тексте запроса 
необходимо описать явное преобразование:

> **await connect.query('INSERT INTO table1(col1) VALUES(CAST($data AS JsonDocument))' {data: {a: 1, b: 2}})**

Соответственно драйвер преобразует типы YDB в типы JS в результате запроса. Преобразуются только "простые" типы,
типы даты в объект Date, JSON и JSON DOCUMENT в объект JS. 

> Преобразование результата было в основном позаимствованно из [ydb-sdk-lite](https://github.com/vitalets/ydb-sdk-lite).
Предполагалось, что можно будет вообще воспользоваться этим простым драйвером, но, к сожалению, оказалось, что 
он не поддерживает транзакций.

В остальных случаях необходимо явное приведение типа 
(или преобразование данных к поддерживаемому типу) в тексте запроса:

```JAVASCRIPT
    SELECT col1, Unicode::JoinFromList(AGG_LIST(col2), ",") AS col2_str
        FROM table1
        GROUP BY col1
```

Очень часто результатом запроса должна быть единственная строка, единственный столбец или вообще одно значение. 
В этом случае можно воспользоваться третьим (одна строка) и четвертым (один столбец) параметром функции **query**:

> **let res = await connect.query('SELECT * FROM table1 WHERE col1 = $val', {val: 1}, true)**

результатом будет не массив объектов, а сразу объект строки или undefined (если запрос вернет более одной строки, 
то сгенерируется исключение)

> **let res = await connect.query('SELECT col1 FROM table1, {}, false, true)**

результатом будет массив не объектов, а сразу значений столбца (если запрос вернет больше одного столбца, то сгенерируется исключение)

> **let res = await connect.query(SELECT max(col1) FROM table1, {}, true, true)**

результатом будет просто одно значение или undefined (при возврате более одной строки и/или более одного столбца сгенерируется исключение).

Естественно, для краткости записи можно пользоваться преобразованиями JS:

> **let res = await connect.query(SELECT max(col1) FROM table1, {}, 1, 1)**

У объекта соедининия с БД есть еще асинхронная функция, с помощью которой можно организовать транзакцию:

> const tsn = await connect.tsn()

У полученного объекта транзакции есть точно такая же асинхронная функция **query** для выполнения запросов.
А для завершения транзакции асинхронные функции **commit()** и **rollback()** без аргументов.

